<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Mec√¢nica Newtoniana</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.2em;
            color: #ffffff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .simulation-area {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .canvas-container {
            flex: 2;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            position: relative;
        }
        
        canvas {
            border: 2px solid #ddd;
            border-radius: 10px;
            cursor: crosshair;
            display: block;
            margin: 0 auto;
        }
        
        .controls {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .control-group {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            border-left: 4px solid #4CAF50;
        }
        
        .control-group h3 {
            margin: 0 0 15px 0;
            color: #ffffff;
            font-size: 1.1em;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #f0f0f0;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
            accent-color: #4CAF50;
        }
        
        input[type="number"] {
            width: 80px;
            padding: 5px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }
        
        button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }
        
        .info-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .physics-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .physics-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }
        
        .physics-item strong {
            color: #4CAF50;
            font-size: 1.1em;
        }
        
        .mode-selector {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .mode-btn {
            margin: 0 10px;
            background: linear-gradient(45deg, #2196F3, #1976D2);
        }
        
        .mode-btn.active {
            background: linear-gradient(45deg, #FF9800, #F57C00);
        }
        
        .explanation {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            border-left: 4px solid #2196F3;
        }
        
        .force-diagram {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 10;
            width: 200px;
        }
        
        .force-diagram h4 {
            margin-top: 0;
            color: #333;
            text-align: center;
            border-bottom: 1px solid #ddd;
            padding-bottom: 8px;
        }
        
        .force-legend {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .force-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
        }
        
        .force-label {
            color: #333;
            font-size: 0.9em;
        }
        
        .force-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .force-btn {
            flex: 1;
            min-width: 120px;
            padding: 8px;
            font-size: 14px;
        }
        
        .force-type-btn {
            background: linear-gradient(45deg, #9C27B0, #7B1FA2);
        }
        
        .force-type-btn.active {
            background: linear-gradient(45deg, #FF9800, #F57C00);
            box-shadow: 0 0 0 2px white;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî¨ Simulador Interativo de Mec√¢nica Newtoniana</h1>
        
        <div class="mode-selector">
            <button class="mode-btn active" onclick="setMode('forces')">For√ßas e Trajet√≥rias</button>
            <button class="mode-btn" onclick="setMode('circular')">Movimento Circular</button>
            <button class="mode-btn" onclick="setMode('work')">Trabalho e Energia</button>
        </div>
        
        <div class="simulation-area">
            <div class="canvas-container">
                <div class="force-diagram">
                    <h4>Diagrama de For√ßas</h4>
                    <div class="force-legend">
                        <div class="force-color" style="background: #2196F3;"></div>
                        <div class="force-label">Part√≠cula</div>
                    </div>
                    <div class="force-legend">
                        <div class="force-color" style="background: #4CAF50;"></div>
                        <div class="force-label">Velocidade</div>
                    </div>
                    <div class="force-legend">
                        <div class="force-color" style="background: #FF5722;"></div>
                        <div class="force-label">For√ßa</div>
                    </div>
                    <div class="force-legend">
                        <div class="force-color" style="background: #9C27B0;"></div>
                        <div class="force-label">For√ßa Central</div>
                    </div>
                    <div class="force-legend">
                        <div class="force-color" style="background: #FF9800;"></div>
                        <div class="force-label">Resultante</div>
                    </div>
                </div>
                <canvas id="canvas" width="800" height="600"></canvas>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <h3>‚öôÔ∏è Controles de Simula√ß√£o</h3>
                    <button onclick="startSimulation()">‚ñ∂Ô∏è Iniciar</button>
                    <button onclick="pauseSimulation()">‚è∏Ô∏è Pausar</button>
                    <button onclick="resetSimulation()">üîÑ Reset</button>
                    <button onclick="toggleTrail()">‚ú® Rastro</button>
                    <button onclick="toggleForceVectors()">‚ÜóÔ∏è Vetores de For√ßa</button>
                </div>
                
                <div class="control-group">
                    <h3>üéØ Propriedades da Part√≠cula</h3>
                    <label>Massa (kg): <span id="massValue">1.0</span></label>
                    <input type="range" id="mass" min="0.5" max="5" step="0.1" value="1.0" oninput="updateMass()">
                    
                    <label>Velocidade Inicial (m/s): <span id="velocityValue">50</span></label>
                    <input type="range" id="initialVelocity" min="10" max="100" step="5" value="50" oninput="updateVelocity()">
                </div>
                
                <div class="control-group" id="forceControls">
                    <h3>‚ö° Campo de For√ßas</h3>
                    <div class="force-controls">
                        <button class="force-type-btn" onclick="setForceType('point')" id="pointForceBtn">Ponto</button>
                        <button class="force-type-btn" onclick="setForceType('radial')" id="radialForceBtn">Radial</button>
                        <button class="force-type-btn" onclick="setForceType('uniform')" id="uniformForceBtn">Uniforme</button>
                    </div>
                    
                    <label>Intensidade: <span id="forceValue">20</span></label>
                    <input type="range" id="forceStrength" min="-100" max="100" step="5" value="20" oninput="updateForce()">
                    
                    <div class="force-controls">
                        <button onclick="toggleGravity()">üåç Gravidade</button>
                        <button onclick="clearForces()">üßπ Limpar For√ßas</button>
                    </div>
                </div>
                
                <div class="control-group" id="circularControls" style="display:none;">
                    <h3>üîÑ Movimento Circular</h3>
                    <label>Raio (m): <span id="radiusValue">150</span></label>
                    <input type="range" id="radius" min="50" max="250" step="10" value="150" oninput="updateRadius()">
                    
                    <label>Velocidade Angular (rad/s): <span id="angularVelValue">1.0</span></label>
                    <input type="range" id="angularVel" min="0.1" max="3.0" step="0.1" value="1.0" oninput="updateAngularVel()">
                </div>
            </div>
        </div>
        
        <div class="info-panel">
            <h3>üìä Informa√ß√µes F√≠sicas em Tempo Real</h3>
            <div class="physics-display">
                <div class="physics-item">
                    <strong>Posi√ß√£o (m)</strong><br>
                    <span id="position">x: 0, y: 0</span>
                </div>
                <div class="physics-item">
                    <strong>Velocidade (m/s)</strong><br>
                    <span id="velocity">v‚Çì: 0, v·µß: 0</span>
                </div>
                <div class="physics-item">
                    <strong>Acelera√ß√£o (m/s¬≤)</strong><br>
                    <span id="acceleration">a‚Çì: 0, a·µß: 0</span>
                </div>
                <div class="physics-item">
                    <strong>For√ßa Resultante (N)</strong><br>
                    <span id="force">F‚Çì: 0, F·µß: 0</span>
                </div>
                <div class="physics-item">
                    <strong>Energia Cin√©tica (J)</strong><br>
                    <span id="kineticEnergy">0</span>
                </div>
                <div class="physics-item">
                    <strong>Momento Angular (kg‚ãÖm¬≤/s)</strong><br>
                    <span id="angularMomentum">0</span>
                </div>
            </div>
            
            <div class="explanation" id="explanation">
                <strong>üí° Dica:</strong> Clique no canvas para adicionar for√ßas pontuais! Observe como as for√ßas alteram a trajet√≥ria e experimente com diferentes massas e velocidades iniciais.
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Estado da simula√ß√£o
        let animationId;
        let isRunning = false;
        let currentMode = 'forces';
        let showTrail = true;
        let showForceVectors = true;
        let trail = [];
        let currentForceType = 'point'; // 'point', 'radial', 'uniform'
        
        // Propriedades da part√≠cula
        let particle = {
            x: 100,
            y: 300,
            vx: 50,
            vy: 0,
            ax: 0,
            ay: 0,
            mass: 1.0,
            radius: 8
        };
        
        // For√ßas
        let forces = [];
        let hasGravity = false;
        let uniformForce = null;
        let centralForce = null;
        
        // Para movimento circular
        let circularMotion = {
            centerX: 400,
            centerY: 300,
            radius: 150,
            angle: 0,
            angularVel: 1.0
        };
        
        // Configura√ß√µes
        const dt = 0.016; // ~60 FPS
        const scale = 1; // metros por pixel
        
        function setMode(mode) {
            currentMode = mode;
            
            // Atualizar bot√µes
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Mostrar/ocultar controles
            document.getElementById('forceControls').style.display = 
                mode === 'forces' ? 'block' : 'none';
            document.getElementById('circularControls').style.display = 
                mode === 'circular' ? 'block' : 'none';
                
            resetSimulation();
            updateExplanation();
        }
        
        function setForceType(type) {
            currentForceType = type;
            
            // Atualizar bot√µes
            document.querySelectorAll('.force-type-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Limpar for√ßas existentes do tipo que n√£o est√° mais selecionado
            if (type !== 'radial') centralForce = null;
            if (type !== 'uniform') uniformForce = null;
            
            // Atualizar bot√µes de for√ßa
            document.querySelector('button[onclick="addRadialForce()"]').style.backgroundColor = 
                type === 'radial' ? '#9C27B0' : '';
        }
        
        function updateExplanation() {
            const explanations = {
                'forces': 'üí° <strong>Modo For√ßas:</strong> Clique no canvas para adicionar for√ßas! Use os bot√µes para selecionar o tipo de for√ßa: pontual, radial ou uniforme. Observe como a for√ßa resultante altera a trajet√≥ria. Note que F = ma - a acelera√ß√£o √© sempre na dire√ß√£o da for√ßa resultante.',
                'circular': 'üí° <strong>Modo Circular:</strong> Veja o movimento circular uniforme! A for√ßa centr√≠peta aponta sempre para o centro. O momento angular L = mvr permanece constante quando n√£o h√° torque externo.',
                'work': 'üí° <strong>Modo Trabalho:</strong> Observe como a energia cin√©tica varia conforme a part√≠cula se move. O trabalho realizado pelas for√ßas altera a energia cin√©tica: W = ŒîK.'
            };
            document.getElementById('explanation').innerHTML = explanations[currentMode];
        }
        
        function startSimulation() {
            if (!isRunning) {
                isRunning = true;
                animate();
            }
        }
        
        function pauseSimulation() {
            isRunning = false;
            cancelAnimationFrame(animationId);
        }
        
        function resetSimulation() {
            pauseSimulation();
            particle = {
                x: 100,
                y: 300,
                vx: parseFloat(document.getElementById('initialVelocity').value),
                vy: 0,
                ax: 0,
                ay: 0,
                mass: parseFloat(document.getElementById('mass').value),
                radius: 8
            };
            
            if (currentMode === 'circular') {
                circularMotion.angle = 0;
            }
            
            trail = [];
            clearCanvas();
            draw();
        }
        
        function toggleTrail() {
            showTrail = !showTrail;
            if (!showTrail) trail = [];
        }
        
        function toggleForceVectors() {
            showForceVectors = !showForceVectors;
        }
        
        function clearCanvas() {
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        function calculateForces() {
            let fx = 0, fy = 0;
            
            if (currentMode === 'forces') {
                // Gravidade
                if (hasGravity) {
                    fy += particle.mass * 9.81 * 10; // Amplificado para visualiza√ß√£o
                }
                
                // For√ßas pontuais
                forces.forEach(force => {
                    const dx = force.x - particle.x;
                    const dy = force.y - particle.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > 0) {
                        fx += force.strength * dx / dist;
                        fy += force.strength * dy / dist;
                    }
                });
                
                // For√ßa uniforme (campo constante)
                if (uniformForce) {
                    fx += uniformForce.fx;
                    fy += uniformForce.fy;
                }
                
                // For√ßa central (radial)
                if (centralForce) {
                    const dx = centralForce.x - particle.x;
                    const dy = centralForce.y - particle.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > 0) {
                        fx += centralForce.strength * dx / (dist * dist) * 1000; // Lei do inverso do quadrado
                        fy += centralForce.strength * dy / (dist * dist) * 1000;
                    }
                }
            } else if (currentMode === 'circular') {
                // For√ßa centr√≠peta para movimento circular
                const dx = circularMotion.centerX - particle.x;
                const dy = circularMotion.centerY - particle.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const centripetal = particle.mass * circularMotion.angularVel * circularMotion.angularVel * circularMotion.radius;
                if (dist > 0) {
                    fx = centripetal * dx / dist;
                    fy = centripetal * dy / dist;
                }
            }
            
            return { fx, fy };
        }
        
        function updatePhysics() {
            if (currentMode === 'circular') {
                // Movimento circular param√©trico
                circularMotion.angle += circularMotion.angularVel * dt;
                particle.x = circularMotion.centerX + circularMotion.radius * Math.cos(circularMotion.angle);
                particle.y = circularMotion.centerY + circularMotion.radius * Math.sin(circularMotion.angle);
                particle.vx = -circularMotion.radius * circularMotion.angularVel * Math.sin(circularMotion.angle);
                particle.vy = circularMotion.radius * circularMotion.angularVel * Math.cos(circularMotion.angle);
            } else {
                // Integra√ß√£o num√©rica (Euler)
                const { fx, fy } = calculateForces();
                
                particle.ax = fx / particle.mass;
                particle.ay = fy / particle.mass;
                
                particle.vx += particle.ax * dt;
                particle.vy += particle.ay * dt;
                
                particle.x += particle.vx * dt;
                particle.y += particle.vy * dt;
                
                // Colis√µes com as bordas
                if (particle.x < particle.radius || particle.x > canvas.width - particle.radius) {
                    particle.vx *= -0.8;
                    particle.x = Math.max(particle.radius, Math.min(canvas.width - particle.radius, particle.x));
                }
                if (particle.y < particle.radius || particle.y > canvas.height - particle.radius) {
                    particle.vy *= -0.8;
                    particle.y = Math.max(particle.radius, Math.min(canvas.height - particle.radius, particle.y));
                }
            }
            
            // Adicionar ao rastro
            if (showTrail) {
                trail.push({ x: particle.x, y: particle.y });
                if (trail.length > 200) trail.shift();
            }
            
            updateDisplays();
        }
        
        function drawForceVector(x, y, fx, fy, color, scale = 1) {
            if (!showForceVectors) return;
            
            const magnitude = Math.sqrt(fx * fx + fy * fy);
            if (magnitude < 0.1) return; // N√£o desenhar vetores muito pequenos
            
            const arrowLength = Math.min(100, magnitude * scale);
            const arrowDx = (fx / magnitude) * arrowLength;
            const arrowDy = (fy / magnitude) * arrowLength;
            
            // Desenhar linha
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + arrowDx, y + arrowDy);
            ctx.stroke();
            
            // Desenhar ponta da seta
            const headLength = 10;
            const angle = Math.atan2(arrowDy, arrowDx);
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x + arrowDx, y + arrowDy);
            ctx.lineTo(
                x + arrowDx - headLength * Math.cos(angle - Math.PI / 6),
                y + arrowDy - headLength * Math.sin(angle - Math.PI / 6)
            );
            ctx.lineTo(
                x + arrowDx - headLength * Math.cos(angle + Math.PI / 6),
                y + arrowDy - headLength * Math.sin(angle + Math.PI / 6)
            );
            ctx.closePath();
            ctx.fill();
        }
        
        function draw() {
            clearCanvas();
            
            // Desenhar grade
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Desenhar rastro
            if (showTrail && trail.length > 1) {
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.moveTo(trail[0].x, trail[0].y);
                for (let i = 1; i < trail.length; i++) {
                    ctx.lineTo(trail[i].x, trail[i].y);
                }
                ctx.stroke();
                ctx.globalAlpha = 1.0;
            }
            
            // Desenhar for√ßas pontuais
            forces.forEach(force => {
                ctx.fillStyle = force.strength > 0 ? '#FF5722' : '#2196F3';
                ctx.beginPath();
                ctx.arc(force.x, force.y, 6, 0, 2 * Math.PI);
                ctx.fill();
                
                // Calcular dire√ß√£o da for√ßa
                const dx = particle.x - force.x;
                const dy = particle.y - force.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > 0) {
                    const strength = Math.abs(force.strength);
                    const arrowDx = (dx / dist) * Math.min(30, strength / 2) * Math.sign(force.strength);
                    const arrowDy = (dy / dist) * Math.min(30, strength / 2) * Math.sign(force.strength);
                    
                    drawForceVector(force.x, force.y, arrowDx, arrowDy, force.strength > 0 ? '#FF5722' : '#2196F3', 1);
                }
            });
            
            // Desenhar for√ßa uniforme
            if (uniformForce) {
                // Desenhar setas representando o campo uniforme
                const spacing = 50;
                const arrowLength = 20;
                const countX = Math.floor(canvas.width / spacing);
                const countY = Math.floor(canvas.height / spacing);
                
                ctx.strokeStyle = '#FF5722';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.6;
                
                for (let i = 0; i < countX; i++) {
                    for (let j = 0; j < countY; j++) {
                        const x = i * spacing + spacing/2;
                        const y = j * spacing + spacing/2;
                        
                        const magnitude = Math.sqrt(uniformForce.fx * uniformForce.fx + uniformForce.fy * uniformForce.fy);
                        const arrowDx = (uniformForce.fx / magnitude) * arrowLength;
                        const arrowDy = (uniformForce.fy / magnitude) * arrowLength;
                        
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + arrowDx, y + arrowDy);
                        ctx.stroke();
                    }
                }
                ctx.globalAlpha = 1.0;
            }
            
            // Desenhar for√ßa central
            if (centralForce) {
                ctx.fillStyle = '#9C27B0';
                ctx.beginPath();
                ctx.arc(centralForce.x, centralForce.y, 8, 0, 2 * Math.PI);
                ctx.fill();
                
                // C√≠rculos conc√™ntricos para indicar campo
                for (let r = 20; r <= 100; r += 20) {
                    ctx.strokeStyle = '#9C27B0';
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath();
                    ctx.arc(centralForce.x, centralForce.y, r, 0, 2 * Math.PI);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1.0;
                
                // Vetor for√ßa
                const dx = particle.x - centralForce.x;
                const dy = particle.y - centralForce.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > 0) {
                    const strength = centralForce.strength / (dist * dist) * 1000;
                    const arrowDx = (dx / dist) * Math.min(30, strength / 10);
                    const arrowDy = (dy / dist) * Math.min(30, strength / 10);
                    
                    drawForceVector(centralForce.x, centralForce.y, -arrowDx, -arrowDy, '#9C27B0', 1);
                }
            }
            
            // Desenhar centro do movimento circular
            if (currentMode === 'circular') {
                ctx.strokeStyle = '#FF9800';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(circularMotion.centerX, circularMotion.centerY, circularMotion.radius, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.setLineDash([]);
                
                ctx.fillStyle = '#FF9800';
                ctx.beginPath();
                ctx.arc(circularMotion.centerX, circularMotion.centerY, 6, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // Desenhar part√≠cula
            ctx.fillStyle = '#2196F3';
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, particle.radius, 0, 2 * Math.PI);
            ctx.fill();
            
            // Vetor velocidade
            drawForceVector(particle.x, particle.y, particle.vx * 0.1, particle.vy * 0.1, '#4CAF50', 1);
            
            // Vetor acelera√ß√£o
            if (particle.ax !== 0 || particle.ay !== 0) {
                drawForceVector(particle.x, particle.y, particle.ax * 2, particle.ay * 2, '#FF5722', 1);
            }
            
            // Vetor for√ßa resultante
            const { fx, fy } = calculateForces();
            if (fx !== 0 || fy !== 0) {
                drawForceVector(particle.x, particle.y, fx * 0.5, fy * 0.5, '#FF9800', 1);
            }
        }
        
        function animate() {
            if (isRunning) {
                updatePhysics();
                draw();
                animationId = requestAnimationFrame(animate);
            }
        }
        
        function updateDisplays() {
            // Atualizar displays num√©ricos
            document.getElementById('position').textContent = 
                `x: ${(particle.x * scale).toFixed(1)}, y: ${((canvas.height - particle.y) * scale).toFixed(1)}`;
            document.getElementById('velocity').textContent = 
                `v‚Çì: ${particle.vx.toFixed(1)}, v·µß: ${(-particle.vy).toFixed(1)}`;
            document.getElementById('acceleration').textContent = 
                `a‚Çì: ${particle.ax.toFixed(1)}, a·µß: ${(-particle.ay).toFixed(1)}`;
            
            const { fx, fy } = calculateForces();
            document.getElementById('force').textContent = 
                `F‚Çì: ${fx.toFixed(1)}, F·µß: ${(-fy).toFixed(1)}`;
            
            const ke = 0.5 * particle.mass * (particle.vx * particle.vx + particle.vy * particle.vy);
            document.getElementById('kineticEnergy').textContent = ke.toFixed(1);
            
            // Momento angular em rela√ß√£o ao centro (ou origem)
            let centerX = currentMode === 'circular' ? circularMotion.centerX : canvas.width / 2;
            let centerY = currentMode === 'circular' ? circularMotion.centerY : canvas.height / 2;
            const rx = particle.x - centerX;
            const ry = particle.y - centerY;
            const angularMomentum = particle.mass * (rx * particle.vy - ry * particle.vx);
            document.getElementById('angularMomentum').textContent = angularMomentum.toFixed(1);
        }
        
        // Event listeners
        canvas.addEventListener('click', (e) => {
            if (currentMode === 'forces') {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const strength = parseFloat(document.getElementById('forceStrength').value);
                
                if (currentForceType === 'point') {
                    forces.push({ x, y, strength });
                } else if (currentForceType === 'radial') {
                    centralForce = { x, y, strength };
                } else if (currentForceType === 'uniform') {
                    // Converter for√ßa em vetor unit√°rio
                    const angle = Math.atan2(y - canvas.height/2, x - canvas.width/2);
                    const fx = Math.cos(angle) * strength;
                    const fy = Math.sin(angle) * strength;
                    uniformForce = { fx, fy };
                }
            }
        });
        
        function updateMass() {
            const value = parseFloat(document.getElementById('mass').value);
            particle.mass = value;
            document.getElementById('massValue').textContent = value.toFixed(1);
        }
        
        function updateVelocity() {
            const value = parseFloat(document.getElementById('initialVelocity').value);
            document.getElementById('velocityValue').textContent = value;
            if (!isRunning) {
                particle.vx = value;
            }
        }
        
        function updateForce() {
            const value = parseFloat(document.getElementById('forceStrength').value);
            document.getElementById('forceValue').textContent = value;
            
            // Atualizar for√ßa uniforme se existir
            if (uniformForce) {
                const angle = Math.atan2(uniformForce.fy, uniformForce.fx);
                uniformForce.fx = Math.cos(angle) * value;
                uniformForce.fy = Math.sin(angle) * value;
            }
        }
        
        function updateRadius() {
            const value = parseFloat(document.getElementById('radius').value);
            circularMotion.radius = value;
            document.getElementById('radiusValue').textContent = value;
        }
        
        function updateAngularVel() {
            const value = parseFloat(document.getElementById('angularVel').value);
            circularMotion.angularVel = value;
            document.getElementById('angularVelValue').textContent = value.toFixed(1);
        }
        
        function toggleGravity() {
            hasGravity = !hasGravity;
            event.target.style.backgroundColor = hasGravity ? '#4CAF50' : '';
        }
        
        function clearForces() {
            forces = [];
            centralForce = null;
            uniformForce = null;
            hasGravity = false;
            document.querySelector('button[onclick="toggleGravity()"]').style.backgroundColor = '';
        }
        
        // Inicializa√ß√£o
        setForceType('point');
        updateExplanation();
        draw();
        updateDisplays();
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Mec√¢nica Newtoniana</title>
    <style>
        /* Aproveitando as vari√°veis CSS do seu sistema */
        :root {
          /* Cores do tema √Årvore */
          --primary-dark: #1a2b4c;
          --primary-medium: #2c4a78;
          --primary-light: #4a6741;
          --primary-extra-light: #3a4b3d;
          --accent-blue: #4fc3f7;
          --accent-green: #81c784;
          --accent-orange: #ffb74d;
          --wood-dark: #6d4c41;
          --wood-light: #8d6e63;
          --leaf-green: #4caf50;
          
          /* Cores para simula√ß√µes */
          --simulation-panel-bg: rgba(15, 23, 42, 0.92);
          --simulation-border: rgba(79, 195, 247, 0.3);
          --simulation-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
          --transition-smooth: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
          
          /* Cores gerais */
          --sidebar-bg: #1e3a8a;
          --content-bg: #f9fafb;
          --text-dark: #0f172a;
          --text-medium: #1e293b;
          --text-light: #f9fafb;
          --text-muted: #e0e0e0;
        }

        /* Reset b√°sico aproveitando do seu CSS */
        * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
        }

        body {
          font-family: 'EB Garamond', serif;
          color: var(--text-light);
          min-height: 100vh;
          background: linear-gradient(to bottom, 
            var(--primary-dark) 0%, 
            var(--primary-medium) 30%, 
            var(--primary-light) 70%, 
            var(--primary-extra-light) 100%);
        }

        /* Container principal usando o estilo do livro */
        .simulation-main-container {
          max-width: 1600px;
          margin: 0 auto;
          padding: 2rem;
          min-height: 100vh;
        }

        /* Cabe√ßalho da simula√ß√£o */
        .simulation-header {
          background: var(--simulation-panel-bg);
          backdrop-filter: blur(12px);
          border-radius: 20px;
          padding: 2.5rem;
          margin-bottom: 2rem;
          border: 1px solid var(--simulation-border);
          box-shadow: var(--simulation-shadow);
          text-align: center;
        }

        .simulation-title {
          font-size: 3rem;
          color: var(--accent-blue);
          margin-bottom: 1rem;
          text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .simulation-subtitle {
          font-size: 1.3rem;
          color: var(--text-muted);
          opacity: 0.9;
        }

        /* Seletor de modo */
        .simulation-mode-selector {
          text-align: center;
          margin-bottom: 2rem;
          display: flex;
          justify-content: center;
          gap: 1rem;
          flex-wrap: wrap;
        }

        .simulation-mode-btn {
          background: linear-gradient(45deg, var(--accent-blue), var(--primary-medium));
          color: white;
          border: none;
          border-radius: 15px;
          padding: 1rem 2rem;
          font-size: 1.1rem;
          font-weight: 600;
          cursor: pointer;
          transition: var(--transition-smooth);
          box-shadow: 0 4px 15px rgba(79, 195, 247, 0.3);
          position: relative;
          overflow: hidden;
        }

        .simulation-mode-btn:hover {
          transform: translateY(-2px);
          box-shadow: 0 8px 25px rgba(79, 195, 247, 0.4);
        }

        .simulation-mode-btn.active {
          background: linear-gradient(45deg, var(--accent-orange), var(--wood-light));
          box-shadow: 0 0 0 3px rgba(255, 183, 77, 0.5);
        }

        /* Layout principal da simula√ß√£o */
        .simulation-area {
          display: grid;
          grid-template-columns: 2fr 1fr;
          gap: 2rem;
          margin-bottom: 2rem;
        }

        /* Container do canvas */
        .simulation-canvas-container {
          background: var(--simulation-panel-bg);
          backdrop-filter: blur(12px);
          border-radius: 20px;
          padding: 2rem;
          border: 1px solid var(--simulation-border);
          box-shadow: var(--simulation-shadow);
          position: relative;
          transition: var(--transition-smooth);
        }

        .simulation-canvas-container:hover {
          transform: translateY(-2px);
          box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
        }

        .simulation-canvas {
          border: 2px solid var(--simulation-border);
          border-radius: 12px;
          background: rgba(255, 255, 255, 0.98);
          box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
          display: block;
          margin: 0 auto;
          cursor: crosshair;
          transition: var(--transition-smooth);
        }

        .simulation-canvas:hover {
          box-shadow: 0 12px 40px rgba(79, 195, 247, 0.3);
        }

        /* Painel de controles */
        .simulation-controls-panel {
          background: var(--simulation-panel-bg);
          backdrop-filter: blur(12px);
          border-radius: 20px;
          padding: 2rem;
          border: 1px solid var(--simulation-border);
          box-shadow: var(--simulation-shadow);
          height: fit-content;
        }

        /* Grupos de controles */
        .simulation-control-group {
          margin-bottom: 2rem;
          padding: 1.5rem;
          background: rgba(79, 195, 247, 0.1);
          border-radius: 15px;
          border-left: 4px solid var(--accent-green);
          transition: var(--transition-smooth);
        }

        .simulation-control-group:hover {
          background: rgba(79, 195, 247, 0.15);
          border-left-color: var(--accent-orange);
        }

        .simulation-control-group-title {
          font-size: 1.4rem;
          color: var(--accent-blue);
          margin-bottom: 1.5rem;
          font-weight: 600;
          display: flex;
          align-items: center;
          gap: 0.5rem;
        }

        /* Labels */
        .simulation-control-label {
          display: block;
          margin-bottom: 0.8rem;
          font-weight: 600;
          color: var(--text-muted);
          font-size: 1.1rem;
        }

        /* Sliders estilizados */
        .simulation-slider {
          width: 100%;
          height: 8px;
          background: rgba(79, 195, 247, 0.2);
          outline: none;
          border-radius: 8px;
          appearance: none;
          cursor: pointer;
          transition: var(--transition-smooth);
          margin-bottom: 1rem;
        }

        .simulation-slider::-webkit-slider-thumb {
          appearance: none;
          width: 24px;
          height: 24px;
          background: linear-gradient(45deg, var(--accent-orange), var(--accent-green));
          border-radius: 50%;
          cursor: pointer;
          box-shadow: 0 4px 12px rgba(255, 183, 77, 0.4);
          transition: var(--transition-smooth);
        }

        .simulation-slider::-webkit-slider-thumb:hover {
          transform: scale(1.2);
          box-shadow: 0 6px 16px rgba(255, 183, 77, 0.6);
        }

        /* Displays de valores */
        .simulation-value-display {
          background: rgba(79, 195, 247, 0.1);
          padding: 0.5rem 1rem;
          border-radius: 8px;
          border: 1px solid var(--simulation-border);
          color: var(--accent-blue);
          font-weight: bold;
          text-align: center;
          display: inline-block;
          min-width: 70px;
          font-family: 'Courier New', monospace;
        }

        /* Inputs num√©ricos */
        .simulation-number-input {
          background: rgba(15, 23, 42, 0.8);
          color: var(--text-light);
          border: 1px solid var(--simulation-border);
          border-radius: 8px;
          padding: 0.6rem;
          font-size: 1rem;
          width: 100px;
          text-align: center;
          transition: var(--transition-smooth);
        }

        .simulation-number-input:focus {
          border-color: var(--accent-blue);
          box-shadow: 0 0 0 2px rgba(79, 195, 247, 0.3);
          outline: none;
        }

        /* Bot√µes de a√ß√£o */
        .simulation-action-btn {
          background: linear-gradient(45deg, var(--accent-blue), var(--accent-green));
          color: white;
          border: none;
          border-radius: 12px;
          padding: 1rem 1.5rem;
          font-size: 1rem;
          font-weight: 600;
          cursor: pointer;
          transition: var(--transition-smooth);
          box-shadow: 0 4px 15px rgba(79, 195, 247, 0.3);
          margin: 0.3rem;
          position: relative;
          overflow: hidden;
        }

        .simulation-action-btn:hover {
          transform: translateY(-2px);
          box-shadow: 0 8px 25px rgba(79, 195, 247, 0.4);
        }

        .simulation-action-btn:active {
          transform: translateY(0);
        }

        /* Bot√µes de tipo de for√ßa */
        .simulation-force-type-btn {
          background: linear-gradient(45deg, var(--wood-dark), var(--wood-light));
          margin: 0.3rem;
          padding: 0.8rem 1.2rem;
          font-size: 0.9rem;
          flex: 1;
          min-width: 100px;
        }

        .simulation-force-type-btn.active {
          background: linear-gradient(45deg, var(--accent-orange), var(--wood-light));
          box-shadow: 0 0 0 2px rgba(255, 183, 77, 0.7);
        }

        /* Container para bot√µes de for√ßa */
        .simulation-force-controls {
          display: flex;
          flex-wrap: wrap;
          gap: 0.5rem;
          margin-bottom: 1rem;
        }

        /* Diagrama de for√ßas */
        .simulation-force-diagram {
          position: absolute;
          top: 2rem;
          right: 2rem;
          background: rgba(255, 255, 255, 0.95);
          border-radius: 15px;
          padding: 1.5rem;
          box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
          z-index: 10;
          width: 220px;
          border: 1px solid var(--simulation-border);
          backdrop-filter: blur(8px);
        }

        .simulation-force-diagram h4 {
          margin-top: 0;
          color: var(--text-dark);
          text-align: center;
          border-bottom: 2px solid var(--accent-blue);
          padding-bottom: 0.5rem;
          margin-bottom: 1rem;
          font-size: 1.2rem;
        }

        .simulation-force-legend {
          display: flex;
          align-items: center;
          margin-bottom: 0.8rem;
          transition: var(--transition-smooth);
        }

        .simulation-force-legend:hover {
          transform: translateX(3px);
        }

        .simulation-force-color {
          width: 18px;
          height: 18px;
          border-radius: 50%;
          margin-right: 12px;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .simulation-force-label {
          color: var(--text-dark);
          font-size: 0.95rem;
          font-weight: 500;
        }

        /* Painel de informa√ß√µes f√≠sicas */
        .simulation-info-panel {
          background: var(--simulation-panel-bg);
          backdrop-filter: blur(12px);
          border-radius: 20px;
          padding: 2rem;
          margin-top: 2rem;
          border: 1px solid var(--simulation-border);
          box-shadow: var(--simulation-shadow);
        }

        .simulation-info-title {
          font-size: 1.8rem;
          color: var(--accent-blue);
          margin-bottom: 1.5rem;
          text-align: center;
          display: flex;
          align-items: center;
          justify-content: center;
          gap: 0.5rem;
        }

        .simulation-physics-display {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
          gap: 1.5rem;
          margin-bottom: 2rem;
        }

        .simulation-physics-item {
          background: rgba(79, 195, 247, 0.1);
          padding: 1.2rem;
          border-radius: 12px;
          text-align: center;
          border: 1px solid rgba(79, 195, 247, 0.2);
          transition: var(--transition-smooth);
        }

        .simulation-physics-item:hover {
          background: rgba(79, 195, 247, 0.15);
          transform: translateY(-2px);
        }

        .simulation-physics-item strong {
          color: var(--accent-green);
          font-size: 1.2rem;
          display: block;
          margin-bottom: 0.5rem;
        }

        .simulation-physics-value {
          font-family: 'Courier New', monospace;
          font-size: 1.1rem;
          color: var(--text-muted);
        }

        /* Explica√ß√£o */
        .simulation-explanation {
          background: rgba(129, 199, 132, 0.1);
          padding: 1.5rem;
          border-radius: 12px;
          border-left: 4px solid var(--accent-green);
          font-size: 1.1rem;
          line-height: 1.6;
        }

        /* Estados especiais dos bot√µes */
        .simulation-btn-gravity {
          background: linear-gradient(45deg, var(--leaf-green), var(--accent-green));
        }

        .simulation-btn-gravity.active {
          background: linear-gradient(45deg, var(--accent-orange), var(--wood-light));
          box-shadow: 0 0 15px rgba(255, 183, 77, 0.6);
        }

        /* Responsividade */
        @media (max-width: 1200px) {
          .simulation-area {
            grid-template-columns: 1fr;
          }
          
          .simulation-force-diagram {
            position: relative;
            top: 0;
            right: 0;
            width: 100%;
            margin-bottom: 1rem;
          }
        }

        @media (max-width: 768px) {
          .simulation-main-container {
            padding: 1rem;
          }
          
          .simulation-header,
          .simulation-canvas-container,
          .simulation-controls-panel,
          .simulation-info-panel {
            padding: 1.5rem;
          }
          
          .simulation-title {
            font-size: 2.5rem;
          }
          
          .simulation-mode-selector {
            flex-direction: column;
            align-items: center;
          }
          
          .simulation-mode-btn {
            width: 100%;
            max-width: 300px;
          }
          
          .simulation-physics-display {
            grid-template-columns: 1fr;
          }
          
          .simulation-force-controls {
            flex-direction: column;
          }
          
          .simulation-force-type-btn {
            flex: none;
            width: 100%;
          }
        }

        /* Anima√ß√µes personalizadas */
        @keyframes simulation-pulse {
          0% { box-shadow: 0 0 0 0 rgba(79, 195, 247, 0.7); }
          70% { box-shadow: 0 0 0 10px rgba(79, 195, 247, 0); }
          100% { box-shadow: 0 0 0 0 rgba(79, 195, 247, 0); }
        }

        .simulation-pulse-effect {
          animation: simulation-pulse 2s infinite;
        }

        /* Estados de loading */
        .simulation-loading {
          position: relative;
          overflow: hidden;
        }

        .simulation-loading::after {
          content: '';
          position: absolute;
          top: 0;
          left: -100%;
          width: 100%;
          height: 100%;
          background: linear-gradient(90deg, transparent, rgba(79, 195, 247, 0.2), transparent);
          animation: loading-sweep 1.5s infinite;
        }

        @keyframes loading-sweep {
          0% { left: -100%; }
          100% { left: 100%; }
        }
    </style>
</head>
<body>
    <div class="simulation-main-container">
        <!-- Cabe√ßalho -->
        <div class="simulation-header">
            <h1 class="simulation-title">üî¨ Simulador Interativo de Mec√¢nica Newtoniana</h1>
            <p class="simulation-subtitle">Explore as leis de Newton atrav√©s de simula√ß√µes visuais interativas</p>
        </div>

        <!-- Seletor de Modo -->
        <div class="simulation-mode-selector">
            <button class="simulation-mode-btn active" onclick="setMode('forces')">‚ö° For√ßas e Trajet√≥rias</button>
            <button class="simulation-mode-btn" onclick="setMode('circular')">üîÑ Movimento Circular</button>
            <button class="simulation-mode-btn" onclick="setMode('work')">‚öôÔ∏è Trabalho e Energia</button>
        </div>

        <!-- √Årea principal da simula√ß√£o -->
        <div class="simulation-area">
            <!-- Container do Canvas -->
            <div class="simulation-canvas-container">
                <div class="simulation-force-diagram">
                    <h4>Diagrama de For√ßas</h4>
                    <div class="simulation-force-legend">
                        <div class="simulation-force-color" style="background: #2196F3;"></div>
                        <div class="simulation-force-label">Part√≠cula</div>
                    </div>
                    <div class="simulation-force-legend">
                        <div class="simulation-force-color" style="background: #4CAF50;"></div>
                        <div class="simulation-force-label">Velocidade</div>
                    </div>
                    <div class="simulation-force-legend">
                        <div class="simulation-force-color" style="background: #FF5722;"></div>
                        <div class="simulation-force-label">For√ßa</div>
                    </div>
                    <div class="simulation-force-legend">
                        <div class="simulation-force-color" style="background: #9C27B0;"></div>
                        <div class="simulation-force-label">For√ßa Central</div>
                    </div>
                    <div class="simulation-force-legend">
                        <div class="simulation-force-color" style="background: #FF9800;"></div>
                        <div class="simulation-force-label">Resultante</div>
                    </div>
                </div>
                <canvas class="simulation-canvas" id="canvas" width="800" height="600"></canvas>
            </div>

            <!-- Painel de Controles -->
            <div class="simulation-controls-panel">
                <!-- Controles de Simula√ß√£o -->
                <div class="simulation-control-group">
                    <h3 class="simulation-control-group-title">‚öôÔ∏è Controles de Simula√ß√£o</h3>
                    <button class="simulation-action-btn" onclick="startSimulation()">‚ñ∂Ô∏è Iniciar</button>
                    <button class="simulation-action-btn" onclick="pauseSimulation()">‚è∏Ô∏è Pausar</button>
                    <button class="simulation-action-btn" onclick="resetSimulation()">üîÑ Reset</button>
                    <button class="simulation-action-btn" onclick="toggleTrail()">‚ú® Rastro</button>
                    <button class="simulation-action-btn" onclick="toggleForceVectors()">‚ÜóÔ∏è Vetores</button>
                </div>

                <!-- Propriedades da Part√≠cula -->
                <div class="simulation-control-group">
                    <h3 class="simulation-control-group-title">üéØ Propriedades da Part√≠cula</h3>
                    <label class="simulation-control-label">Massa (kg): <span class="simulation-value-display" id="massValue">1.0</span></label>
                    <input type="range" class="simulation-slider" id="mass" min="0.5" max="5" step="0.1" value="1.0" oninput="updateMass()">
                    
                    <label class="simulation-control-label">Velocidade Inicial (m/s): <span class="simulation-value-display" id="velocityValue">50</span></label>
                    <input type="range" class="simulation-slider" id="initialVelocity" min="10" max="100" step="5" value="50" oninput="updateVelocity()">
                </div>

                <!-- Controles de For√ßa -->
                <div class="simulation-control-group" id="forceControls">
                    <h3 class="simulation-control-group-title">‚ö° Campo de For√ßas</h3>
                    <div class="simulation-force-controls">
                        <button class="simulation-force-type-btn active" onclick="setForceType('point')" id="pointForceBtn">üìç Ponto</button>
                        <button class="simulation-force-type-btn" onclick="setForceType('radial')" id="radialForceBtn">üåü Radial</button>
                        <button class="simulation-force-type-btn" onclick="setForceType('uniform')" id="uniformForceBtn">‚û°Ô∏è Uniforme</button>
                    </div>
                    
                    <label class="simulation-control-label">Intensidade: <span class="simulation-value-display" id="forceValue">20</span></label>
                    <input type="range" class="simulation-slider" id="forceStrength" min="-100" max="100" step="5" value="20" oninput="updateForce()">
                    
                    <div class="simulation-force-controls">
                        <button class="simulation-action-btn simulation-btn-gravity" onclick="toggleGravity()">üåç Gravidade</button>
                        <button class="simulation-action-btn" onclick="clearForces()">üßπ Limpar</button>
                    </div>
                </div>

                <!-- Controles de Movimento Circular -->
                <div class="simulation-control-group" id="circularControls" style="display:none;">
                    <h3 class="simulation-control-group-title">üîÑ Movimento Circular</h3>
                    <label class="simulation-control-label">Raio (m): <span class="simulation-value-display" id="radiusValue">150</span></label>
                    <input type="range" class="simulation-slider" id="radius" min="50" max="250" step="10" value="150" oninput="updateRadius()">
                    
                    <label class="simulation-control-label">Velocidade Angular (rad/s): <span class="simulation-value-display" id="angularVelValue">1.0</span></label>
                    <input type="range" class="simulation-slider" id="angularVel" min="0.1" max="3.0" step="0.1" value="1.0" oninput="updateAngularVel()">
                </div>
            </div>
        </div>

        <!-- Painel de Informa√ß√µes F√≠sicas -->
        <div class="simulation-info-panel">
            <h3 class="simulation-info-title">üìä Informa√ß√µes F√≠sicas em Tempo Real</h3>
            <div class="simulation-physics-display">
                <div class="simulation-physics-item">
                    <strong>Posi√ß√£o (m)</strong>
                    <div class="simulation-physics-value" id="position">x: 0, y: 0</div>
                </div>
                <div class="simulation-physics-item">
                    <strong>Velocidade (m/s)</strong>
                    <div class="simulation-physics-value" id="velocity">v‚Çì: 0, v·µß: 0</div>
                </div>
                <div class="simulation-physics-item">
                    <strong>Acelera√ß√£o (m/s¬≤)</strong>
                    <div class="simulation-physics-value" id="acceleration">a‚Çì: 0, a·µß: 0</div>
                </div>
                <div class="simulation-physics-item">
                    <strong>For√ßa Resultante (N)</strong>
                    <div class="simulation-physics-value" id="force">F‚Çì: 0, F·µß: 0</div>
                </div>
                <div class="simulation-physics-item">
                    <strong>Energia Cin√©tica (J)</strong>
                    <div class="simulation-physics-value" id="kineticEnergy">0</div>
                </div>
                <div class="simulation-physics-item">
                    <strong>Momento Angular (kg‚ãÖm¬≤/s)</strong>
                    <div class="simulation-physics-value" id="angularMomentum">0</div>
                </div>
            </div>
            
            <div class="simulation-explanation" id="explanation">
                <strong>üí° Dica:</strong> Clique no canvas para adicionar for√ßas pontuais! Observe como as for√ßas alteram a trajet√≥ria e experimente com diferentes massas e velocidades iniciais.
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Estado da simula√ß√£o
        let animationId;
        let isRunning = false;
        let currentMode = 'forces';
        let showTrail = true;
        let showForceVectors = true;
        let trail = [];
        let currentForceType = 'point'; // 'point', 'radial', 'uniform'
        
        // Propriedades da part√≠cula
        let particle = {
            x: 100,
            y: 300,
            vx: 50,
            vy: 0,
            ax: 0,
            ay: 0,
            mass: 1.0,
            radius: 8
        };
        
        // For√ßas
        let forces = [];
        let hasGravity = false;
        let uniformForce = null;
        let centralForce = null;
        
        // Para movimento circular
        let circularMotion = {
            centerX: 400,
            centerY: 300,
            radius: 150,
            angle: 0,
            angularVel: 1.0
        };
        
        // Configura√ß√µes
        const dt = 0.016; // ~60 FPS
        const scale = 1; // metros por pixel
        
        function setMode(mode) {
            currentMode = mode;
            
            // Atualizar bot√µes
            document.querySelectorAll('.simulation-mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Mostrar/ocultar controles
            document.getElementById('forceControls').style.display = 
                mode === 'forces' ? 'block' : 'none';
            document.getElementById('circularControls').style.display = 
                mode === 'circular' ? 'block' : 'none';
                
            resetSimulation();
            updateExplanation();
        }
        
        function setForceType(type) {
            currentForceType = type;
            
            // Atualizar bot√µes
            document.querySelectorAll('.simulation-force-type-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Limpar for√ßas existentes do tipo que n√£o est√° mais selecionado
            if (type !== 'radial') centralForce = null;
            if (type !== 'uniform') uniformForce = null;
        }
        
        function updateExplanation() {
            const explanations = {
                'forces': 'üí° <strong>Modo For√ßas:</strong> Clique no canvas para adicionar for√ßas! Use os bot√µes para selecionar o tipo de for√ßa: pontual, radial ou uniforme. Observe como a for√ßa resultante altera a trajet√≥ria. Note que F = ma - a acelera√ß√£o √© sempre na dire√ß√£o da for√ßa resultante.',
                'circular': 'üí° <strong>Modo Circular:</strong> Veja o movimento circular uniforme! A for√ßa centr√≠peta aponta sempre para o centro. O momento angular L = mvr permanece constante quando n√£o h√° torque externo.',
                'work': 'üí° <strong>Modo Trabalho:</strong> Observe como a energia cin√©tica varia conforme a part√≠cula se move. O trabalho realizado pelas for√ßas altera a energia cin√©tica: W = ŒîK.'
            };
            document.getElementById('explanation').innerHTML = explanations[currentMode];
        }
        
        function startSimulation() {
            if (!isRunning) {
                isRunning = true;
                animate();
            }
        }
        
        function pauseSimulation() {
            isRunning = false;
            cancelAnimationFrame(animationId);
        }
        
        function resetSimulation() {
            pauseSimulation();
            particle = {
                x: 100,
                y: 300,
                vx: parseFloat(document.getElementById('initialVelocity').value),
                vy: 0,
                ax: 0,
                ay: 0,
                mass: parseFloat(document.getElementById('mass').value),
                radius: 8
            };
            
            if (currentMode === 'circular') {
                circularMotion.angle = 0;
            }
            
            trail = [];
            clearCanvas();
            draw();
        }
        
        function toggleTrail() {
            showTrail = !showTrail;
            if (!showTrail) trail = [];
        }
        
        function toggleForceVectors() {
            showForceVectors = !showForceVectors;
        }
        
        function clearCanvas() {
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        function calculateForces() {
            let fx = 0, fy = 0;
            
            if (currentMode === 'forces') {
                // Gravidade
                if (hasGravity) {
                    fy += particle.mass * 9.81 * 10; // Amplificado para visualiza√ß√£o
                }
                
                // For√ßas pontuais
                forces.forEach(force => {
                    const dx = force.x - particle.x;
                    const dy = force.y - particle.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > 0) {
                        fx += force.strength * dx / dist;
                        fy += force.strength * dy / dist;
                    }
                });
                
                // For√ßa uniforme (campo constante)
                if (uniformForce) {
                    fx += uniformForce.fx;
                    fy += uniformForce.fy;
                }
                
                // For√ßa central (radial)
                if (centralForce) {
                    const dx = centralForce.x - particle.x;
                    const dy = centralForce.y - particle.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > 0) {
                        fx += centralForce.strength * dx / (dist * dist) * 1000; // Lei do inverso do quadrado
                        fy += centralForce.strength * dy / (dist * dist) * 1000;
                    }
                }
            } else if (currentMode === 'circular') {
                // For√ßa centr√≠peta para movimento circular
                const dx = circularMotion.centerX - particle.x;
                const dy = circularMotion.centerY - particle.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const centripetal = particle.mass * circularMotion.angularVel * circularMotion.angularVel * circularMotion.radius;
                if (dist > 0) {
                    fx = centripetal * dx / dist;
                    fy = centripetal * dy / dist;
                }
            }
            
            return { fx, fy };
        }
        
        function updatePhysics() {
            if (currentMode === 'circular') {
                // Movimento circular param√©trico
                circularMotion.angle += circularMotion.angularVel * dt;
                particle.x = circularMotion.centerX + circularMotion.radius * Math.cos(circularMotion.angle);
                particle.y = circularMotion.centerY + circularMotion.radius * Math.sin(circularMotion.angle);
                particle.vx = -circularMotion.radius * circularMotion.angularVel * Math.sin(circularMotion.angle);
                particle.vy = circularMotion.radius * circularMotion.angularVel * Math.cos(circularMotion.angle);
            } else {
                // Integra√ß√£o num√©rica (Euler)
                const { fx, fy } = calculateForces();
                
                particle.ax = fx / particle.mass;
                particle.ay = fy / particle.mass;
                
                particle.vx += particle.ax * dt;
                particle.vy += particle.ay * dt;
                
                particle.x += particle.vx * dt;
                particle.y += particle.vy * dt;
                
                // Colis√µes com as bordas
                if (particle.x < particle.radius || particle.x > canvas.width - particle.radius) {
                    particle.vx *= -0.8;
                    particle.x = Math.max(particle.radius, Math.min(canvas.width - particle.radius, particle.x));
                }
                if (particle.y < particle.radius || particle.y > canvas.height - particle.radius) {
                    particle.vy *= -0.8;
                    particle.y = Math.max(particle.radius, Math.min(canvas.height - particle.radius, particle.y));
                }
            }
            
            // Adicionar ao rastro
            if (showTrail) {
                trail.push({ x: particle.x, y: particle.y });
                if (trail.length > 200) trail.shift();
            }
            
            updateDisplays();
        }
        
        function drawForceVector(x, y, fx, fy, color, scale = 1) {
            if (!showForceVectors) return;
            
            const magnitude = Math.sqrt(fx * fx + fy * fy);
            if (magnitude < 0.1) return; // N√£o desenhar vetores muito pequenos
            
            const arrowLength = Math.min(100, magnitude * scale);
            const arrowDx = (fx / magnitude) * arrowLength;
            const arrowDy = (fy / magnitude) * arrowLength;
            
            // Desenhar linha
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + arrowDx, y + arrowDy);
            ctx.stroke();
            
            // Desenhar ponta da seta
            const headLength = 10;
            const angle = Math.atan2(arrowDy, arrowDx);
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x + arrowDx, y + arrowDy);
            ctx.lineTo(
                x + arrowDx - headLength * Math.cos(angle - Math.PI / 6),
                y + arrowDy - headLength * Math.sin(angle - Math.PI / 6)
            );
            ctx.lineTo(
                x + arrowDx - headLength * Math.cos(angle + Math.PI / 6),
                y + arrowDy - headLength * Math.sin(angle + Math.PI / 6)
            );
            ctx.closePath();
            ctx.fill();
        }
        
        function draw() {
            clearCanvas();
            
            // Desenhar grade
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Desenhar rastro
            if (showTrail && trail.length > 1) {
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.moveTo(trail[0].x, trail[0].y);
                for (let i = 1; i < trail.length; i++) {
                    ctx.lineTo(trail[i].x, trail[i].y);
                }
                ctx.stroke();
                ctx.globalAlpha = 1.0;
            }
            
            // Desenhar for√ßas pontuais
            forces.forEach(force => {
                ctx.fillStyle = force.strength > 0 ? '#FF5722' : '#2196F3';
                ctx.beginPath();
                ctx.arc(force.x, force.y, 6, 0, 2 * Math.PI);
                ctx.fill();
                
                // Calcular dire√ß√£o da for√ßa
                const dx = particle.x - force.x;
                const dy = particle.y - force.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > 0) {
                    const strength = Math.abs(force.strength);
                    const arrowDx = (dx / dist) * Math.min(30, strength / 2) * Math.sign(force.strength);
                    const arrowDy = (dy / dist) * Math.min(30, strength / 2) * Math.sign(force.strength);
                    
                    drawForceVector(force.x, force.y, arrowDx, arrowDy, force.strength > 0 ? '#FF5722' : '#2196F3', 1);
                }
            });
            
            // Desenhar for√ßa uniforme
            if (uniformForce) {
                // Desenhar setas representando o campo uniforme
                const spacing = 50;
                const arrowLength = 20;
                const countX = Math.floor(canvas.width / spacing);
                const countY = Math.floor(canvas.height / spacing);
                
                ctx.strokeStyle = '#FF5722';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.6;
                
                for (let i = 0; i < countX; i++) {
                    for (let j = 0; j < countY; j++) {
                        const x = i * spacing + spacing/2;
                        const y = j * spacing + spacing/2;
                        
                        const magnitude = Math.sqrt(uniformForce.fx * uniformForce.fx + uniformForce.fy * uniformForce.fy);
                        if (magnitude > 0) {
                            const arrowDx = (uniformForce.fx / magnitude) * arrowLength;
                            const arrowDy = (uniformForce.fy / magnitude) * arrowLength;
                            
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(x + arrowDx, y + arrowDy);
                            ctx.stroke();
                        }
                    }
                }
                ctx.globalAlpha = 1.0;
            }
            
            // Desenhar for√ßa central
            if (centralForce) {
                ctx.fillStyle = '#9C27B0';
                ctx.beginPath();
                ctx.arc(centralForce.x, centralForce.y, 8, 0, 2 * Math.PI);
                ctx.fill();
                
                // C√≠rculos conc√™ntricos para indicar campo
                for (let r = 20; r <= 100; r += 20) {
                    ctx.strokeStyle = '#9C27B0';
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath();
                    ctx.arc(centralForce.x, centralForce.y, r, 0, 2 * Math.PI);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1.0;
                
                // Vetor for√ßa
                const dx = particle.x - centralForce.x;
                const dy = particle.y - centralForce.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > 0) {
                    const strength = centralForce.strength / (dist * dist) * 1000;
                    const arrowDx = (dx / dist) * Math.min(30, strength / 10);
                    const arrowDy = (dy / dist) * Math.min(30, strength / 10);
                    
                    drawForceVector(centralForce.x, centralForce.y, -arrowDx, -arrowDy, '#9C27B0', 1);
                }
            }
            
            // Desenhar centro do movimento circular
            if (currentMode === 'circular') {
                ctx.strokeStyle = '#FF9800';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(circularMotion.centerX, circularMotion.centerY, circularMotion.radius, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.setLineDash([]);
                
                ctx.fillStyle = '#FF9800';
                ctx.beginPath();
                ctx.arc(circularMotion.centerX, circularMotion.centerY, 6, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // Desenhar part√≠cula
            ctx.fillStyle = '#2196F3';
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, particle.radius, 0, 2 * Math.PI);
            ctx.fill();
            
            // Vetor velocidade
            drawForceVector(particle.x, particle.y, particle.vx * 0.1, particle.vy * 0.1, '#4CAF50', 1);
            
            // Vetor acelera√ß√£o
            if (particle.ax !== 0 || particle.ay !== 0) {
                drawForceVector(particle.x, particle.y, particle.ax * 2, particle.ay * 2, '#FF5722', 1);
            }
            
            // Vetor for√ßa resultante
            const { fx, fy } = calculateForces();
            if (fx !== 0 || fy !== 0) {
                drawForceVector(particle.x, particle.y, fx * 0.5, fy * 0.5, '#FF9800', 1);
            }
        }
        
        function animate() {
            if (isRunning) {
                updatePhysics();
                draw();
                animationId = requestAnimationFrame(animate);
            }
        }
        
        function updateDisplays() {
            // Atualizar displays num√©ricos
            document.getElementById('position').textContent = 
                `x: ${(particle.x * scale).toFixed(1)}, y: ${((canvas.height - particle.y) * scale).toFixed(1)}`;
            document.getElementById('velocity').textContent = 
                `v‚Çì: ${particle.vx.toFixed(1)}, v·µß: ${(-particle.vy).toFixed(1)}`;
            document.getElementById('acceleration').textContent = 
                `a‚Çì: ${particle.ax.toFixed(1)}, a·µß: ${(-particle.ay).toFixed(1)}`;
            
            const { fx, fy } = calculateForces();
            document.getElementById('force').textContent = 
                `F‚Çì: ${fx.toFixed(1)}, F·µß: ${(-fy).toFixed(1)}`;
            
            const ke = 0.5 * particle.mass * (particle.vx * particle.vx + particle.vy * particle.vy);
            document.getElementById('kineticEnergy').textContent = ke.toFixed(1);
            
            // Momento angular em rela√ß√£o ao centro (ou origem)
            let centerX = currentMode === 'circular' ? circularMotion.centerX : canvas.width / 2;
            let centerY = currentMode === 'circular' ? circularMotion.centerY : canvas.height / 2;
            const rx = particle.x - centerX;
            const ry = particle.y - centerY;
            const angularMomentum = particle.mass * (rx * particle.vy - ry * particle.vx);
            document.getElementById('angularMomentum').textContent = angularMomentum.toFixed(1);
        }
        
        // Event listeners
        canvas.addEventListener('click', (e) => {
            if (currentMode === 'forces') {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const strength = parseFloat(document.getElementById('forceStrength').value);
                
                if (currentForceType === 'point') {
                    forces.push({ x, y, strength });
                } else if (currentForceType === 'radial') {
                    centralForce = { x, y, strength };
                } else if (currentForceType === 'uniform') {
                    // Converter for√ßa em vetor unit√°rio
                    const angle = Math.atan2(y - canvas.height/2, x - canvas.width/2);
                    const fx = Math.cos(angle) * strength;
                    const fy = Math.sin(angle) * strength;
                    uniformForce = { fx, fy };
                }
            }
        });
        
        function updateMass() {
            const value = parseFloat(document.getElementById('mass').value);
            particle.mass = value;
            document.getElementById('massValue').textContent = value.toFixed(1);
        }
        
        function updateVelocity() {
            const value = parseFloat(document.getElementById('initialVelocity').value);
            document.getElementById('velocityValue').textContent = value;
            if (!isRunning) {
                particle.vx = value;
            }
        }
        
        function updateForce() {
            const value = parseFloat(document.getElementById('forceStrength').value);
            document.getElementById('forceValue').textContent = value;
            
            // Atualizar for√ßa uniforme se existir
            if (uniformForce) {
                const angle = Math.atan2(uniformForce.fy, uniformForce.fx);
                uniformForce.fx = Math.cos(angle) * value;
                uniformForce.fy = Math.sin(angle) * value;
            }
        }
        
        function updateRadius() {
            const value = parseFloat(document.getElementById('radius').value);
            circularMotion.radius = value;
            document.getElementById('radiusValue').textContent = value;
        }
        
        function updateAngularVel() {
            const value = parseFloat(document.getElementById('angularVel').value);
            circularMotion.angularVel = value;
            document.getElementById('angularVelValue').textContent = value.toFixed(1);
        }
        
        function toggleGravity() {
            hasGravity = !hasGravity;
            const btn = event.target;
            if (hasGravity) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        }
        
        function clearForces() {
            forces = [];
            centralForce = null;
            uniformForce = null;
            hasGravity = false;
            document.querySelector('.simulation-btn-gravity').classList.remove('active');
        }
        
        // Inicializa√ß√£o
        setForceType('point');
        updateExplanation();
        draw();
        updateDisplays();
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bordo e Orientação - Simulação Interativa</title>
    <style>
        /* Variáveis CSS do tema unificado */
        :root {
            /* Cores do tema Árvore */
            --primary-dark: #1a2b4c;
            --primary-medium: #2c4a78;
            --primary-light: #4a6741;
            --primary-extra-light: #3a4b3d;
            --accent-blue: #4fc3f7;
            --accent-green: #81c784;
            --accent-orange: #ffb74d;
            --wood-dark: #6d4c41;
            --wood-light: #8d6e63;
            --leaf-green: #4caf50;
            
            /* Cores para simulação */
            --simulation-bg: rgba(15, 23, 42, 0.92);
            --simulation-panel-bg: rgba(26, 43, 76, 0.95);
            --simulation-border: rgba(79, 195, 247, 0.3);
            --simulation-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            --text-light: #f9fafb;
            --text-muted: #e0e0e0;
            --transition-smooth: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }

        /* Reset e configuração base */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'EB Garamond', serif;
            background: linear-gradient(to bottom, 
                var(--primary-dark) 0%, 
                var(--primary-medium) 30%, 
                var(--primary-light) 70%, 
                var(--primary-extra-light) 100%);
            color: var(--text-light);
            min-height: 100vh;
            padding: 2rem;
            overflow-x: auto;
        }

        /* Container principal da simulação */
        .simulation-main-container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--simulation-bg);
            backdrop-filter: blur(12px);
            border-radius: 20px;
            border: 1px solid var(--simulation-border);
            box-shadow: var(--simulation-shadow);
            overflow: hidden;
        }

        /* Cabeçalho da simulação */
        .simulation-header {
            background: linear-gradient(135deg, 
                rgba(79, 195, 247, 0.15) 0%, 
                rgba(129, 199, 132, 0.15) 100%);
            padding: 2.5rem;
            text-align: center;
            border-bottom: 1px solid var(--simulation-border);
        }

        .simulation-header h1 {
            font-size: 2.8rem;
            color: var(--accent-blue);
            margin-bottom: 0.5rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            font-weight: 600;
        }

        .simulation-header p {
            color: var(--text-muted);
            font-size: 1.2rem;
            opacity: 0.9;
        }

        /* Grid de conteúdo */
        .simulation-content-grid {
            display: grid;
            grid-template-columns: 380px 1fr;
        }

        /* Painel de controles */
        .simulation-controls-panel {
            background: var(--simulation-panel-bg);
            backdrop-filter: blur(8px);
            padding: 2rem;
            border-right: 1px solid var(--simulation-border);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* Grupos de controles */
        .simulation-control-section {
            margin-bottom: 1.8rem;
            padding-bottom: 1.2rem;
            border-bottom: 1px solid rgba(79, 195, 247, 0.2);
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
        }

        .simulation-control-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .simulation-control-group-title {
            color: var(--accent-green);
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 1.2rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .simulation-control-group-title::before {
            content: '';
            width: 4px;
            height: 20px;
            background: var(--accent-green);
            border-radius: 2px;
        }

        /* Controles individuais */
        .simulation-control-group {
            margin-bottom: 1.2rem;
        }

        .simulation-control-label {
            display: block;
            color: var(--text-light);
            font-weight: 500;
            margin-bottom: 0.5rem;
            font-size: 1rem;
        }

        /* Sliders */
        .simulation-slider-container {
            position: relative;
            margin-bottom: 0.5rem;
        }

        .simulation-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(79, 195, 247, 0.2);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            transition: var(--transition-smooth);
        }

        .simulation-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-blue);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(79, 195, 247, 0.4);
            transition: var(--transition-smooth);
        }

        .simulation-slider::-webkit-slider-thumb:hover {
            background: var(--accent-green);
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(129, 199, 132, 0.6);
        }

        .simulation-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-blue);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(79, 195, 247, 0.4);
        }

        /* Valor do slider */
        .simulation-slider-value {
            color: var(--accent-orange);
            font-weight: bold;
            font-size: 0.95rem;
            margin-left: 0.5rem;
        }

        /* Select boxes */
        .simulation-select {
            width: 100%;
            padding: 0.8rem 1rem;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(79, 195, 247, 0.3);
            border-radius: 8px;
            color: var(--text-light);
            font-size: 1rem;
            transition: var(--transition-smooth);
        }

        .simulation-select:focus {
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(79, 195, 247, 0.2);
        }

        .simulation-select option {
            background: var(--primary-dark);
            color: var(--text-light);
        }

        /* Checkboxes */
        .simulation-checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.8rem;
        }

        .simulation-checkbox {
            width: 20px;
            height: 20px;
            accent-color: var(--accent-blue);
            cursor: pointer;
        }

        /* Área visual */
        .simulation-visual-area {
            padding: 2rem;
            background: rgba(15, 23, 42, 0.5);
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        /* Grid de canvas */
        .simulation-canvas-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            flex: 1;
        }

        /* Container do canvas */
        .simulation-canvas-container {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--simulation-border);
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .simulation-canvas-title {
            color: var(--accent-blue);
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 1rem;
            text-align: center;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        /* Canvas */
        .simulation-canvas {
            width: 100%;
            height: 400px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(79, 195, 247, 0.2);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Painel de informações */
        .simulation-info-panel {
            background: linear-gradient(135deg, 
                rgba(79, 195, 247, 0.15) 0%, 
                rgba(129, 199, 132, 0.15) 100%);
            border-radius: 12px;
            padding: 2rem;
            border: 1px solid var(--simulation-border);
            backdrop-filter: blur(8px);
        }

        .simulation-info-title {
            color: var(--accent-green);
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .simulation-formula {
            background: rgba(0, 0, 0, 0.3);
            padding: 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            border-left: 4px solid var(--accent-orange);
            color: var(--accent-orange);
            font-weight: bold;
        }

        /* Grid de informações */
        .simulation-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }

        .simulation-info-card {
            background: rgba(0, 0, 0, 0.2);
            padding: 1.2rem;
            border-radius: 8px;
            border-left: 4px solid var(--accent-blue);
            backdrop-filter: blur(5px);
        }

        .simulation-info-card h4 {
            color: var(--accent-blue);
            margin-bottom: 0.8rem;
            font-size: 1.1rem;
        }

        .simulation-info-card p {
            color: var(--text-muted);
            line-height: 1.6;
            font-size: 0.95rem;
        }

        /* Responsividade para tablets */
        @media (max-width: 1024px) {
            .simulation-content-grid {
                grid-template-columns: 1fr;
            }
            
            .simulation-controls-panel {
                border-right: none;
                border-bottom: 1px solid var(--simulation-border);
                flex-direction: row;
                flex-wrap: wrap;
                gap: 1rem;
            }
            
            .simulation-control-section {
                flex: 1;
                min-width: 250px;
                margin-bottom: 1rem;
                border-bottom: none;
                border-right: 1px solid rgba(79, 195, 247, 0.2);
                padding-right: 1rem;
            }
            
            .simulation-control-section:last-child {
                border-right: none;
            }
            
            .simulation-canvas-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Responsividade para mobile */
        @media (max-width: 768px) {
            body {
                padding: 1rem;
            }
            
            .simulation-header {
                padding: 1.5rem;
            }
            
            .simulation-header h1 {
                font-size: 2.2rem;
            }
            
            .simulation-controls-panel {
                padding: 1.5rem;
                flex-direction: column;
            }
            
            .simulation-control-section {
                border-right: none;
                border-bottom: 1px solid rgba(79, 195, 247, 0.2);
                padding-right: 0;
                margin-bottom: 1.5rem;
            }
            
            .simulation-visual-area {
                padding: 1.5rem;
            }
            
            .simulation-canvas {
                height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="simulation-main-container">
        <!-- Cabeçalho -->
        <div class="simulation-header">
            <h1>Simulação: Bordo, Orientação e Vetores Normais</h1>
            <p>Explore a relação entre orientação da superfície e direção de percurso do bordo</p>
        </div>

        <!-- Grid de conteúdo -->
        <div class="simulation-content-grid">
            <!-- Painel de controles -->
            <div class="simulation-controls-panel">
                <!-- Tipo de superfície -->
                <div class="simulation-control-section">
                    <h4 class="simulation-control-group-title">Tipo de Superfície</h4>
                    <div class="simulation-control-group">
                        <label class="simulation-control-label" for="surfaceType">Função base:</label>
                        <select id="surfaceType" class="simulation-select">
                            <option value="wave">Ondas senoidais</option>
                            <option value="paraboloid">Paraboloide</option>
                            <option value="saddle">Ponto de sela</option>
                            <option value="cylinder">Cilindro</option>
                            <option value="custom">Personalizada</option>
                        </select>
                    </div>
                    <div class="simulation-control-group">
                        <div class="simulation-checkbox-group">
                            <input type="checkbox" id="reverseOrientation" class="simulation-checkbox">
                            <label class="simulation-control-label" for="reverseOrientation">Inverter orientação (N → -N)</label>
                        </div>
                    </div>
                </div>

                <!-- Parâmetros -->
                <div class="simulation-control-section">
                    <h4 class="simulation-control-group-title">Parâmetros da Superfície</h4>
                    <div class="simulation-control-group">
                        <label class="simulation-control-label" for="amplitude">Amplitude:</label>
                        <div class="simulation-slider-container">
                            <input type="range" id="amplitude" class="simulation-slider" min="0.2" max="3" step="0.1" value="1.0">
                            <span class="simulation-slider-value" id="amplitudeValue">1.0</span>
                        </div>
                    </div>
                    <div class="simulation-control-group">
                        <label class="simulation-control-label" for="frequency">Frequência:</label>
                        <div class="simulation-slider-container">
                            <input type="range" id="frequency" class="simulation-slider" min="0.5" max="4" step="0.1" value="1.5">
                            <span class="simulation-slider-value" id="frequencyValue">1.5</span>
                        </div>
                    </div>
                    <div class="simulation-control-group">
                        <label class="simulation-control-label" for="stretch">Estiramento X:</label>
                        <div class="simulation-slider-container">
                            <input type="range" id="stretch" class="simulation-slider" min="0.5" max="2" step="0.1" value="1.0">
                            <span class="simulation-slider-value" id="stretchValue">1.0</span>
                        </div>
                    </div>
                    <div class="simulation-control-group">
                        <label class="simulation-control-label" for="skew">Inclinação Y:</label>
                        <div class="simulation-slider-container">
                            <input type="range" id="skew" class="simulation-slider" min="0.5" max="2" step="0.1" value="1.0">
                            <span class="simulation-slider-value" id="skewValue">1.0</span>
                        </div>
                    </div>
                </div>

                <!-- Visualização -->
                <div class="simulation-control-section">
                    <h4 class="simulation-control-group-title">Visualização</h4>
                    <div class="simulation-control-group">
                        <label class="simulation-control-label" for="rotation">Rotação:</label>
                        <div class="simulation-slider-container">
                            <input type="range" id="rotation" class="simulation-slider" min="0" max="360" step="5" value="30">
                            <span class="simulation-slider-value" id="rotationValue">30°</span>
                        </div>
                    </div>
                    <div class="simulation-control-group">
                        <div class="simulation-checkbox-group">
                            <input type="checkbox" id="showNormals" class="simulation-checkbox" checked>
                            <label class="simulation-control-label" for="showNormals">Vetores normais</label>
                        </div>
                    </div>
                    <div class="simulation-control-group">
                        <div class="simulation-checkbox-group">
                            <input type="checkbox" id="showGrid" class="simulation-checkbox" checked>
                            <label class="simulation-control-label" for="showGrid">Grade</label>
                        </div>
                    </div>
                    <div class="simulation-control-group">
                        <label class="simulation-control-label" for="normalDensity">Densidade normais:</label>
                        <div class="simulation-slider-container">
                            <input type="range" id="normalDensity" class="simulation-slider" min="3" max="10" step="1" value="6">
                            <span class="simulation-slider-value" id="normalDensityValue">6</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Área visual -->
            <div class="simulation-visual-area">
                <!-- Grid de canvas -->
                <div class="simulation-canvas-grid">
                    <div class="simulation-canvas-container">
                        <h3 class="simulation-canvas-title">Superfície com Vetores Normais</h3>
                        <canvas id="surfaceCanvas" class="simulation-canvas"></canvas>
                    </div>
                    
                    <div class="simulation-canvas-container">
                        <h3 class="simulation-canvas-title">Domínio e Orientação do Bordo</h3>
                        <canvas id="domainCanvas" class="simulation-canvas"></canvas>
                    </div>
                </div>

                <!-- Painel de informações -->
                <div class="simulation-info-panel">
                    <h3 class="simulation-info-title">Relação entre Orientação da Superfície e do Bordo</h3>
                    
                    <div class="simulation-formula" id="formulaDisplay">
                        ∂C percorrido no sentido anti-horário
                    </div>
                    
                    <div class="simulation-info-grid">
                        <div class="simulation-info-card">
                            <h4>Regra da Mão Direita</h4>
                            <p>O vetor normal <strong>N</strong> determina como percorrer o bordo. Com N apontando para você, o bordo é percorrido no <strong>sentido anti-horário</strong>.</p>
                        </div>
                        
                        <div class="simulation-info-card">
                            <h4>Inversão de Orientação</h4>
                            <p>Ao inverter N → -N, o sentido de percurso do bordo também inverte. As setas mostram a direção de integração ao longo de ∂C.</p>
                        </div>
                        
                        <div class="simulation-info-card">
                            <h4>Fórmula do Bordo</h4>
                            <p><strong>∂C = C₂₀ + C₁₁ - C₂₁ - C₁₀</strong><br>
                            Cada Cᵢⱼ representa um segmento do bordo com orientação específica determinada por N.</p>
                        </div>
                        
                        <div class="simulation-info-card">
                            <h4>Experimente</h4>
                            <p>Mude o tipo de superfície e observe como os vetores normais se comportam. Inverta a orientação para ver como isso afeta o sentido de percurso do bordo!</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuração dos canvas
        const surfaceCanvas = document.getElementById('surfaceCanvas');
        const domainCanvas = document.getElementById('domainCanvas');
        const surfaceCtx = surfaceCanvas.getContext('2d');
        const domainCtx = domainCanvas.getContext('2d');
        
        // Configurar tamanho dos canvas
        function resizeCanvas() {
            const rect = surfaceCanvas.parentElement.getBoundingClientRect();
            surfaceCanvas.width = rect.width - 32; // Accounting for padding
            surfaceCanvas.height = 400;
            
            const domainRect = domainCanvas.parentElement.getBoundingClientRect();
            domainCanvas.width = domainRect.width - 32;
            domainCanvas.height = 400;
            
            draw();
        }
        
        window.addEventListener('resize', resizeCanvas);
        
        // Parâmetros da simulação
        let params = {
            surfaceType: 'wave',
            amplitude: 1.0,
            frequency: 1.5,
            stretch: 1.0,
            skew: 1.0,
            rotation: 30,
            showNormals: true,
            showGrid: true,
            normalDensity: 6,
            reverseOrientation: false
        };
        
        // Controles
        const controls = {
            surfaceType: document.getElementById('surfaceType'),
            amplitude: document.getElementById('amplitude'),
            frequency: document.getElementById('frequency'),
            stretch: document.getElementById('stretch'),
            skew: document.getElementById('skew'),
            rotation: document.getElementById('rotation'),
            showNormals: document.getElementById('showNormals'),
            showGrid: document.getElementById('showGrid'),
            normalDensity: document.getElementById('normalDensity'),
            reverseOrientation: document.getElementById('reverseOrientation')
        };
        
        const values = {
            amplitude: document.getElementById('amplitudeValue'),
            frequency: document.getElementById('frequencyValue'),
            stretch: document.getElementById('stretchValue'),
            skew: document.getElementById('skewValue'),
            rotation: document.getElementById('rotationValue'),
            normalDensity: document.getElementById('normalDensityValue')
        };
        
        // Event listeners para controles
        Object.keys(controls).forEach(key => {
            if (key === 'showNormals' || key === 'showGrid' || key === 'reverseOrientation') {
                controls[key].addEventListener('change', (e) => {
                    params[key] = e.target.checked;
                    updateFormulaDisplay();
                    draw();
                });
            } else if (key === 'surfaceType') {
                controls[key].addEventListener('change', (e) => {
                    params[key] = e.target.value;
                    draw();
                });
            } else {
                controls[key].addEventListener('input', (e) => {
                    params[key] = parseFloat(e.target.value);
                    if (values[key]) {
                        values[key].textContent = key === 'rotation' ? `${params[key]}°` : params[key];
                    }
                    draw();
                });
            }
        });
        
        // Atualizar exibição da fórmula
        function updateFormulaDisplay() {
            const formulaDisplay = document.getElementById('formulaDisplay');
            
            if (params.reverseOrientation) {
                formulaDisplay.innerHTML = '∂C percorrido no <strong>sentido horário</strong>';
            } else {
                formulaDisplay.innerHTML = '∂C percorrido no <strong>sentido anti-horário</strong>';
            }
        }
        
        // Funções das superfícies
        function surfaceFunction(u, v) {
            let x, y, z;
            
            switch (params.surfaceType) {
                case 'wave':
                    x = u * params.stretch + 0.2 * Math.sin(params.frequency * v) * params.amplitude;
                    y = v * params.skew + 0.2 * Math.cos(params.frequency * u) * params.amplitude;
                    z = 0.3 * Math.sin(params.frequency * u) * Math.cos(params.frequency * v) * params.amplitude;
                    break;
                    
                case 'paraboloid':
                    x = u * params.stretch;
                    y = v * params.skew;
                    z = params.amplitude * (u * u + v * v) * 0.5;
                    break;
                    
                case 'saddle':
                    x = u * params.stretch;
                    y = v * params.skew;
                    z = params.amplitude * (u * u - v * v) * 0.5;
                    break;
                    
                case 'cylinder':
                    const r = 1 + params.amplitude * 0.3;
                    x = r * Math.cos(params.frequency * u) * params.stretch;
                    y = v * params.skew;
                    z = r * Math.sin(params.frequency * u) * params.amplitude;
                    break;
                    
                case 'custom':
                    x = u * params.stretch + 0.1 * Math.sin(params.frequency * u * v) * params.amplitude;
                    y = v * params.skew + 0.1 * Math.cos(params.frequency * u * v) * params.amplitude;
                    z = 0.2 * Math.sin(params.frequency * u) * Math.sin(params.frequency * v) * params.amplitude;
                    break;
                    
                default:
                    x = u; y = v; z = 0;
            }
            
            return [x, y, z];
        }
        
        // Calcular derivadas parciais numericamente
        function partialDerivatives(u, v) {
            const h = 0.001;
            
            const [x, y, z] = surfaceFunction(u, v);
            const [xu1, yu1, zu1] = surfaceFunction(u + h, v);
            const [xu2, yu2, zu2] = surfaceFunction(u, v + h);
            
            const du = [(xu1 - x) / h, (yu1 - y) / h, (zu1 - z) / h];
            const dv = [(xu2 - x) / h, (yu2 - y) / h, (zu2 - z) / h];
            
            return [du, dv];
        }
        
        // Produto vetorial
        function crossProduct(a, b) {
            return [
                a[1] * b[2] - a[2] * b[1],
                a[2] * b[0] - a[0] * b[2],
                a[0] * b[1] - a[1] * b[0]
            ];
        }
        
        // Normalizar vetor
        function normalize(v) {
            const length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
            if (length === 0) return [0, 0, 1];
            return [v[0] / length, v[1] / length, v[2] / length];
        }
        
        // Calcular vetor normal
        function normalVector(u, v) {
            const [du, dv] = partialDerivatives(u, v);
            let normal = crossProduct(du, dv);
            normal = normalize(normal);
            
            if (params.reverseOrientation) {
                normal = [-normal[0], -normal[1], -normal[2]];
            }
            
            return normal;
        }
        
        // Projeção 3D para 2D
        function project3D(x, y, z, canvas) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = Math.min(canvas.width, canvas.height) * 0.25;
            
            const rad = params.rotation * Math.PI / 180;
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);
            
            // Rotação em Y e X para melhor visualização
            const rotY_x = x * cos - z * sin;
            const rotY_z = x * sin + z * cos;
            
            const pitch = 30 * Math.PI / 180;
            const cosP = Math.cos(pitch);
            const sinP = Math.sin(pitch);

            const finalX = rotY_x;
            const finalY = y * cosP - rotY_z * sinP;
            const finalZ = y * sinP + rotY_z * cosP;

            const perspective = 1 + finalZ * 0.1;
            
            return [
                centerX + finalX * scale * perspective,
                centerY - finalY * scale * perspective
            ];
        }
        
        // Desenhar superfície
        function drawSurface() {
            const ctx = surfaceCtx;
            const canvas = surfaceCanvas;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const resolution = 25;
            const uMin = -1.2, uMax = 1.2;
            const vMin = -1.2, vMax = 1.2;
            
            // Desenhar grade da superfície
            if (params.showGrid) {
                ctx.strokeStyle = 'rgba(79, 195, 247, 0.4)';
                ctx.lineWidth = 1;
                
                // Linhas u constante
                for (let i = 0; i <= resolution; i++) {
                    const u = uMin + (uMax - uMin) * i / resolution;
                    ctx.beginPath();
                    
                    for (let j = 0; j <= resolution; j++) {
                        const v = vMin + (vMax - vMin) * j / resolution;
                        const [x, y, z] = surfaceFunction(u, v);
                        const [px, py] = project3D(x, y, z, canvas);
                        
                        if (j === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                }
                
                // Linhas v constante
                for (let j = 0; j <= resolution; j++) {
                    const v = vMin + (vMax - vMin) * j / resolution;
                    ctx.beginPath();
                    
                    for (let i = 0; i <= resolution; i++) {
                        const u = uMin + (uMax - uMin) * i / resolution;
                        const [x, y, z] = surfaceFunction(u, v);
                        const [px, py] = project3D(x, y, z, canvas);
                        
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                }
            }
            
            // Destacar curvas de bordo
            const borderColor = '#4fc3f7'; // Cor do tema unificado
            const curves = [
                { v: vMin, uRange: [uMin, uMax], direction: params.reverseOrientation ? -1 : 1 }, // Inferior
                { u: uMax, vRange: [vMin, vMax], direction: params.reverseOrientation ? -1 : 1 }, // Direita  
                { v: vMax, uRange: [uMax, uMin], direction: params.reverseOrientation ? -1 : 1 }, // Superior (invertida)
                { u: uMin, vRange: [vMax, vMin], direction: params.reverseOrientation ? -1 : 1 }  // Esquerda (invertida)
            ];
            
            curves.forEach(curve => {
                ctx.strokeStyle = borderColor;
                ctx.fillStyle = borderColor;
                ctx.lineWidth = 4;
                
                ctx.beginPath();
                
                let points = [];
                if ('u' in curve) {
                    // Curva com u fixo (bordas esquerda e direita)
                    const [vStart, vEnd] = curve.vRange;
                    for (let i = 0; i <= 50; i++) {
                        const v = vStart + (vEnd - vStart) * i / 50;
                        const [x, y, z] = surfaceFunction(curve.u, v);
                        const [px, py] = project3D(x, y, z, canvas);
                        points.push([px, py]);
                        
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                } else {
                    // Curva com v fixo (bordas inferior e superior)
                    const [uStart, uEnd] = curve.uRange;
                    for (let i = 0; i <= 50; i++) {
                        const v = curve.v;
                        const u = uStart + (uEnd - uStart) * i / 50;
                        const [x, y, z] = surfaceFunction(u, v);
                        const [px, py] = project3D(x, y, z, canvas);
                        points.push([px, py]);
                        
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                }
                ctx.stroke();
                
                // Desenhar setas direcionais ao longo da curva
                const numArrows = 4;
                for (let i = 1; i <= numArrows; i++) {
                    const idx = Math.floor((points.length - 1) * i / (numArrows + 1));
                    if (idx < points.length - 1) {
                        const [x1, y1] = points[idx];
                        const [x2, y2] = points[idx + 1];
                        
                        let dx = x2 - x1;
                        let dy = y2 - y1;
                        
                        // Inverter direção se necessário
                        if (curve.direction < 0) {
                            dx = -dx;
                            dy = -dy;
                        }
                        
                        const length = Math.sqrt(dx * dx + dy * dy);
                        if (length > 1) {
                            const ux = dx / length;
                            const uy = dy / length;
                            const arrowSize = 8;
                            
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x1 - ux * arrowSize + uy * arrowSize * 0.5, y1 - uy * arrowSize - ux * arrowSize * 0.5);
                            ctx.lineTo(x1 - ux * arrowSize - uy * arrowSize * 0.5, y1 - uy * arrowSize + ux * arrowSize * 0.5);
                            ctx.closePath();
                            ctx.fill();
                        }
                    }
                }
            });
            
            // Desenhar vetores normais
            if (params.showNormals) {
                const normalRes = params.normalDensity;
                ctx.strokeStyle = '#81c784'; // Verde do tema
                ctx.lineWidth = 2;
                
                for (let i = 1; i < normalRes; i++) {
                    for (let j = 1; j < normalRes; j++) {
                        const u = uMin + (uMax - uMin) * i / normalRes;
                        const v = vMin + (vMax - vMin) * j / normalRes;
                        
                        const [x, y, z] = surfaceFunction(u, v);
                        const [nx, ny, nz] = normalVector(u, v);
                        
                        const [px1, py1] = project3D(x, y, z, canvas);
                        const [px2, py2] = project3D(x + nx * 0.3, y + ny * 0.3, z + nz * 0.3, canvas);
                        
                        // Vetor normal
                        ctx.beginPath();
                        ctx.moveTo(px1, py1);
                        ctx.lineTo(px2, py2);
                        ctx.stroke();
                        
                        // Ponta da seta
                        const dx = px2 - px1;
                        const dy = py2 - py1;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        
                        if (length > 5) {
                            const ux = dx / length;
                            const uy = dy / length;
                            const arrowSize = 6;
                            
                            ctx.fillStyle = '#81c784';
                            ctx.beginPath();
                            ctx.moveTo(px2, py2);
                            ctx.lineTo(px2 - ux * arrowSize + uy * arrowSize * 0.5, py2 - uy * arrowSize - ux * arrowSize * 0.5);
                            ctx.lineTo(px2 - ux * arrowSize - uy * arrowSize * 0.5, py2 - uy * arrowSize + ux * arrowSize * 0.5);
                            ctx.closePath();
                            ctx.fill();
                        }
                    }
                }
            }
        }
        
        // Desenhar domínio e curvas
        function drawDomain() {
            const ctx = domainCtx;
            const canvas = domainCanvas;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const margin = 60;
            const width = canvas.width - 2 * margin;
            const height = canvas.height - 2 * margin;
            const arrowSize = 10;
            
            // Desenhar eixos
            ctx.strokeStyle = '#e0e0e0';
            ctx.fillStyle = '#e0e0e0';
            ctx.lineWidth = 2;
            ctx.font = 'bold 14px EB Garamond';
            
            // Eixo u
            ctx.beginPath();
            ctx.moveTo(margin - 20, margin + height);
            ctx.lineTo(margin + width + 20, margin + height);
            ctx.stroke();
            ctx.fillText('u', margin + width + 25, margin + height + 5);
            
            // Seta do eixo u
            ctx.beginPath();
            ctx.moveTo(margin + width + 20, margin + height);
            ctx.lineTo(margin + width + 10, margin + height - 5);
            ctx.lineTo(margin + width + 10, margin + height + 5);
            ctx.closePath();
            ctx.fill();
            
            // Eixo v
            ctx.beginPath();
            ctx.moveTo(margin, margin + height + 20);
            ctx.lineTo(margin, margin - 20);
            ctx.stroke();
            ctx.fillText('v', margin - 5, margin - 25);
            
            // Seta do eixo v
            ctx.beginPath();
            ctx.moveTo(margin, margin - 20);
            ctx.lineTo(margin - 5, margin - 10);
            ctx.lineTo(margin + 5, margin - 10);
            ctx.closePath();
            ctx.fill();
            
            // Grade do domínio
            if (params.showGrid) {
                ctx.strokeStyle = 'rgba(79, 195, 247, 0.2)';
                ctx.lineWidth = 1;
                const gridLines = 8;
                for (let i = 1; i < gridLines; i++) {
                    const x = margin + width * i / gridLines;
                    const y = margin + height * i / gridLines;
                    
                    ctx.beginPath();
                    ctx.moveTo(x, margin);
                    ctx.lineTo(x, margin + height);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(margin, y);
                    ctx.lineTo(margin + width, y);
                    ctx.stroke();
                }
            }
            
            // Definir pontos do retângulo (domínio)
            const p1 = [margin, margin];           // Canto superior esquerdo
            const p2 = [margin + width, margin];   // Canto superior direito
            const p3 = [margin + width, margin + height]; // Canto inferior direito
            const p4 = [margin, margin + height];  // Canto inferior esquerdo

            // Definir o caminho do bordo baseado na orientação
            const borderPath = params.reverseOrientation ? 
                [p4, p1, p2, p3, p4] :  // Sentido horário
                [p4, p3, p2, p1, p4];   // Sentido anti-horário
            
            // Desenhar o bordo completo
            ctx.strokeStyle = '#4fc3f7';
            ctx.fillStyle = '#4fc3f7';
            ctx.lineWidth = 4;
            
            // Linha do bordo
            ctx.beginPath();
            ctx.moveTo(borderPath[0][0], borderPath[0][1]);
            for (let i = 1; i < borderPath.length; i++) {
                ctx.lineTo(borderPath[i][0], borderPath[i][1]);
            }
            ctx.stroke();
            
            // Desenhar setas ao longo do bordo
            const totalSegments = borderPath.length - 1;
            const arrowsPerSegment = 3;
            
            for (let segment = 0; segment < totalSegments; segment++) {
                const start = borderPath[segment];
                const end = borderPath[segment + 1];
                
                for (let arrow = 1; arrow <= arrowsPerSegment; arrow++) {
                    const t = arrow / (arrowsPerSegment + 1);
                    const arrowX = start[0] + t * (end[0] - start[0]);
                    const arrowY = start[1] + t * (end[1] - start[1]);
                    const dx = end[0] - start[0];
                    const dy = end[1] - start[1];
                    const angle = Math.atan2(dy, dx);
                    
                    ctx.beginPath();
                    ctx.moveTo(arrowX, arrowY);
                    ctx.lineTo(arrowX - arrowSize * Math.cos(angle - Math.PI / 6), arrowY - arrowSize * Math.sin(angle - Math.PI / 6));
                    ctx.lineTo(arrowX - arrowSize * Math.cos(angle + Math.PI / 6), arrowY - arrowSize * Math.sin(angle + Math.PI / 6));
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            // Desenhar indicador de orientação no centro
            const centerX = margin + width / 2;
            const centerY = margin + height / 2;
            
            ctx.font = 'bold 16px EB Garamond';
            ctx.fillStyle = '#4fc3f7';
            ctx.textAlign = 'center';
            
            const orientationText = params.reverseOrientation ? 
                'Sentido Horário' : 
                'Sentido Anti-horário';
            
            ctx.fillText(orientationText, centerX, centerY - 10);
            
            const subText = params.reverseOrientation ? 
                '(N invertido)' : 
                '(N normal)';
            
            ctx.font = '14px EB Garamond';
            ctx.fillStyle = '#ffb74d';
            ctx.fillText(subText, centerX, centerY + 10);
            
            // Desenhar seta circular indicando direção
            ctx.strokeStyle = '#4fc3f7';
            ctx.lineWidth = 2;
            const radius = 25;
            const startAngle = params.reverseOrientation ? 0 : Math.PI;
            const endAngle = params.reverseOrientation ? -Math.PI * 1.5 : Math.PI * 0.5;
            
            ctx.beginPath();
            ctx.arc(centerX, centerY + 40, radius, startAngle, endAngle, params.reverseOrientation);
            ctx.stroke();
            
            // Seta na extremidade do arco
            const arrowAngle = endAngle;
            const arrowX = centerX + radius * Math.cos(arrowAngle);
            const arrowY = centerY + 40 + radius * Math.sin(arrowAngle);
            const direction = params.reverseOrientation ? -1 : 1;
            
            ctx.fillStyle = '#4fc3f7';
            ctx.beginPath();
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(arrowX - 6 * Math.cos(arrowAngle - direction * Math.PI / 6), 
                      arrowY - 6 * Math.sin(arrowAngle - direction * Math.PI / 6));
            ctx.lineTo(arrowX - 6 * Math.cos(arrowAngle + direction * Math.PI / 6), 
                      arrowY - 6 * Math.sin(arrowAngle + direction * Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }
        
        // Função principal que chama as rotinas de desenho
        function draw() {
            if (!surfaceCanvas || !domainCanvas) return;
            drawSurface();
            drawDomain();
        }
        
        // Inicialização
        updateFormulaDisplay();
        resizeCanvas();
    </script>
</body>
</html>